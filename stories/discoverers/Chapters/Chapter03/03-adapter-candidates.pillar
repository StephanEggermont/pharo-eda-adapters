!! Adapter candidates

After ==EDAAJsonFileDiscoverer== reads a file, it returns dictionaries as adapter candidates. We can think of a "candidate" as something which can become an adapter after ensuring certain conditions are met. It can infer the class of adapter it fits into too.

However, ==EDAAJsonFileDiscoverer== currently returns a list of dictionaries. Let's start by fixing it. We want it to discover candidates we can ask for their nature afterwards.
We need to change all our current tests, but let's focus on the first one for now.

% ${changes:path=code/001-EDAAJsonFileDiscovererTest_testParseAFlatJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseAFlatJsonFile
	| fileContents discoverer |
	fileContents := '{
  "sample": "value"
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 1;
		assert: discoverer candidates first isNotNil;
		assert: discoverer candidates first key equals: 'sample';
		assert: discoverer candidates first value equals: 'value'
]]]

==EDAAJsonFileDiscoverer== cannot return a list of dictionaries, but a list of candidates. And a candidate have a key and a value, albeit their contents are arbitrary.

Let's start with that: defining an initial candidate class, and improve our current discoverer to build candidates instead of just dictionaries.

We need a new test class ==EDAACandidateTest==:
% ${changes:path=code/002-EDAACandidateTest.ombu}$
[[[classDefinition=true|lineNumber=true
TestCase subclass: #EDAACandidateTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EDAA-Domain-Tests'
]]]

% ${changes:path=code/003-EDAACandidateTest_testBuilderMethod.ombu}$
[[[methodDefinition=true|lineNumber=true
testBuilderMethod
	| key candidate value |
	key := 'candidateKey'.
	value := 'candidateValue'.
	candidate := EDAACandidate withKey: key value: value.
	self
		assert: candidate key equals: key;
		assert: candidate value equals: value
]]]

Pharo will help us creating both the new class.

% ${changes:path=code/004-EDAACandidate.ombu}$
[[[classDefinition=true|lineNumber=true
Object subclass: #EDAACandidate
	instanceVariableNames: 'key value'
	classVariableNames: ''
	package: 'EDAA-Domain'
]]]

Let's create the accessors as usual.

% ${changes:path=code/005-EDAACandidate_key.ombu}$
[[[methodDefinition=true|lineNumber=true
key
	^ key
]]]

% ${changes:path=code/006-EDAACandidate_key_.ombu}$
[[[methodDefinition=true|lineNumber=true
key: anObject
	key := anObject
]]]

% ${changes:path=code/007-EDAACandidate_value.ombu}$
[[[methodDefinition=true|lineNumber=true
value
	^ value
]]]

% ${changes:path=code/008-EDAACandidate_value_.ombu}$
[[[methodDefinition=true|lineNumber=true
value: anObject
	value := anObject
]]]

Running the test will make Pharo want to help us creating the builder method as well.

% ${changes:path=code/009-EDAACandidate_class_withKey_value_.ombu}$
[[[methodDefinition=true|lineNumber=true
withKey: aKey value: aValue
	^ self new
		key: aKey;
		value: aValue;
		yourself
]]]

The new test now passes, and we can focus on ""testParseAFlatJsonFile"" in ==EDAAJsonFileDiscovererTest==.
To make it pass, we need to change the implementation of ==EDAJsonFileDiscoverer==. It must return a list of ==EDAACandidate== instances, not dictionaries.

% ${changes:path=code/010-EDAAJsonFileDiscoverer_processJsonFile_.ombu}$
[[[methodDefinition=true|lineNumber=true
processJsonFile: aFile
	| result map |
	result := OrderedCollection new.
	map := (NeoJSONReader on: aFile name readStream) parseMap.
	map
		keysAndValuesDo:
			[ :k :v | result add: (EDAACandidate withKey: k value: v) ].
	^ result
]]]

There're two more tests we need to fix because they are failing after our changes in the nature of the candidate list ==JsonFileDiscoverer== returns.

% ${changes:path=code/011-EDAAJsonFileDiscovererTest_testParseAnothenFlatJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseAnotherFlatJsonFile
	| fileContents discoverer |
	fileContents := '{
  "candidate1": "value1",
  "candidate2": "value2"
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 2;
		assert: discoverer candidates first isNotNil;
		assert: discoverer candidates first key equals: 'candidate1';
		assert: discoverer candidates first value equals: 'value1';
		assert: discoverer candidates second isNotNil;
		assert: discoverer candidates second key equals: 'candidate2';
		assert: discoverer candidates second value equals: 'value2'
]]]

% ${changes:path=code/012-EDAAJsonFileDiscovererTest_testParseCommandListenerAdapterInJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseCommandListenerAdapterInJsonFile
	| fileContents discoverer commandListener |
	fileContents := '{
  "commandListener": {
    "host": "localhost",
    "port": 61613,
    "user": "user",
    "password": "secret",
    "queue": "messages-to-eda",
    "durable": true,
    "ack": "client-individual",
    "prefetchCount": 1,
    "timeout": 60,
    "debug": true,
    "restartOnError": false
  }
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 1;
		assert: discoverer candidates first isNotNil.
	commandListener := discoverer candidates first.
	self
		assert: commandListener isNotNil;
		assert: commandListener key equals: 'commandListener';
		assert: (commandListener value at: 'host') equals: 'localhost';
		assert: (commandListener value at: 'port') equals: 61613;
		assert: (commandListener value at: 'user') equals: 'user';
		assert: (commandListener value at: 'password') equals: 'secret';
		assert: (commandListener value at: 'queue')
			equals: 'messages-to-eda';
		assert: (commandListener value at: 'durable') equals: true;
		assert: (commandListener value at: 'ack')
			equals: 'client-individual';
		assert: (commandListener value at: 'prefetchCount') equals: 1;
		assert: (commandListener value at: 'timeout') equals: 60;
		assert: (commandListener value at: 'debug') equals: true;
		assert: (commandListener value at: 'restartOnError') equals: false
]]]

All tests are passing again.

!!! Figure out the adapter class

We'd like the new ==EDAACandidate== to help us figuring out the actual class of the adapter it represents.
The simplest behavior is to use class names as keys. Let's start with approach.

% ${changes:path=code/013-EDAACandidateTest_testAdapterClassAsCandidateKey.ombu}$
[[[methodDefinition=true|lineNumber=true
testAdapterClassAsCandidateKey
	| candidate |
	candidate := EDAACandidate withKey: 'EDAAMongoEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMongoEventStore
]]]

We have to implement the new method ""adapterClass"".

% ${changes:path=code/014-EDAACandidate_adapterClass.ombu}$
[[[methodDefinition=true|lineNumber=true
adapterClass
	^ #EDAAMongoEventStore
]]]

This has helped us to think of the method name, but the implementation is incorrect. Let's improve the test to fix it.

% ${changes:path=code/015-EDAACandidateTest_testAdapterClassAsCandidateKey.ombu}$
[[[methodDefinition=true|lineNumber=true
testAdapterClassAsCandidateKey
	| candidate |
	candidate := EDAACandidate withKey: 'EDAAMongoEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMongoEventStore.
	candidate := EDAACandidate withKey: 'EDAAMemoryEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMemoryEventStore
]]]

The simplest implementation of ""adapterClass"" passing the test is:

% ${changes:path=code/016-EDAACandidate_adapterClass.ombu}$
[[[methodDefinition=true|lineNumber=true
adapterClass
	^ self key asSymbol
]]]

Using adapter names as keys is a valid approach, but it's not enough for us:
- it's not the most readable format we can think of,
- it's not flexible,
- it doesn't support current PharoEDA configuration files.

EDALogEvent
EDAEventStore
EDAEventSourcingEvent
!! Adapter candidates

After ==EDAAJsonFileDiscoverer== reads a file, it returns dictionaries as adapter candidates. We can think of a "candidate" as something which can become an adapter after ensuring certain conditions are met. It can infer the class of adapter it fits into too.

However, ==EDAAJsonFileDiscoverer== currently returns a list of dictionaries. Let's start by fixing it. We want it to discover candidates we can ask for their nature afterwards.
We need to change all our current tests, but let's focus on the first one for now.

% ${changes:path=code/001-EDAAJsonFileDiscovererTest_testParseAFlatJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseAFlatJsonFile
	| fileContents discoverer |
	fileContents := '{
  "sample": "value"
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 1;
		assert: discoverer candidates first isNotNil;
		assert: discoverer candidates first key equals: 'sample';
		assert: discoverer candidates first value equals: 'value'
]]]

==EDAAJsonFileDiscoverer== cannot return a list of dictionaries, but a list of candidates. And a candidate have a key and a value, albeit their contents are arbitrary.

Let's start with that: defining an initial candidate class, and improve our current discoverer to build candidates instead of just dictionaries.

We need a new test class ==EDAACandidateTest==:
% ${changes:path=code/002-EDAACandidateTest.ombu}$
[[[classDefinition=true|lineNumber=true
TestCase subclass: #EDAACandidateTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EDAA-Domain-Tests'
]]]

% ${changes:path=code/003-EDAACandidateTest_testBuilderMethod.ombu}$
[[[methodDefinition=true|lineNumber=true
testBuilderMethod
	| key candidate value |
	key := 'candidateKey'.
	value := 'candidateValue'.
	candidate := EDAACandidate withKey: key value: value.
	self
		assert: candidate key equals: key;
		assert: candidate value equals: value
]]]

Pharo will help us creating both the new class.

% ${changes:path=code/004-EDAACandidate.ombu}$
[[[classDefinition=true|lineNumber=true
Object subclass: #EDAACandidate
	instanceVariableNames: 'key value'
	classVariableNames: ''
	package: 'EDAA-Domain'
]]]

Let's create the accessors as usual.

% ${changes:path=code/005-EDAACandidate_key.ombu}$
[[[methodDefinition=true|lineNumber=true
key
	^ key
]]]

% ${changes:path=code/006-EDAACandidate_key_.ombu}$
[[[methodDefinition=true|lineNumber=true
key: anObject
	key := anObject
]]]

% ${changes:path=code/007-EDAACandidate_value.ombu}$
[[[methodDefinition=true|lineNumber=true
value
	^ value
]]]

% ${changes:path=code/008-EDAACandidate_value_.ombu}$
[[[methodDefinition=true|lineNumber=true
value: anObject
	value := anObject
]]]

Running the test will make Pharo want to help us creating the builder method as well.

% ${changes:path=code/009-EDAACandidate_class_withKey_value_.ombu}$
[[[methodDefinition=true|lineNumber=true
withKey: aKey value: aValue
	^ self new
		key: aKey;
		value: aValue;
		yourself
]]]

The new test now passes, and we can focus on ""testParseAFlatJsonFile"" in ==EDAAJsonFileDiscovererTest==.
To make it pass, we need to change the implementation of ==EDAJsonFileDiscoverer==. It must return a list of ==EDAACandidate== instances, not dictionaries.

% ${changes:path=code/010-EDAAJsonFileDiscoverer_processJsonFile_.ombu}$
[[[methodDefinition=true|lineNumber=true
processJsonFile: aFile
	| result map |
	result := OrderedCollection new.
	map := (NeoJSONReader on: aFile name readStream) parseMap.
	map
		keysAndValuesDo:
			[ :k :v | result add: (EDAACandidate withKey: k value: v) ].
	^ result
]]]

There're two more tests we need to fix because they are failing after our changes in the nature of the candidate list ==JsonFileDiscoverer== returns.

% ${changes:path=code/011-EDAAJsonFileDiscovererTest_testParseAnothenFlatJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseAnotherFlatJsonFile
	| fileContents discoverer |
	fileContents := '{
  "candidate1": "value1",
  "candidate2": "value2"
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 2;
		assert: discoverer candidates first isNotNil;
		assert: discoverer candidates first key equals: 'candidate1';
		assert: discoverer candidates first value equals: 'value1';
		assert: discoverer candidates second isNotNil;
		assert: discoverer candidates second key equals: 'candidate2';
		assert: discoverer candidates second value equals: 'value2'
]]]

% ${changes:path=code/012-EDAAJsonFileDiscovererTest_testParseCommandListenerAdapterInJsonFile.ombu}$
[[[methodDefinition=true|lineNumber=true
testParseCommandListenerAdapterInJsonFile
	| fileContents discoverer commandListener |
	fileContents := '{
  "commandListener": {
    "host": "localhost",
    "port": 61613,
    "user": "user",
    "password": "secret",
    "queue": "messages-to-eda",
    "durable": true,
    "ack": "client-individual",
    "prefetchCount": 1,
    "timeout": 60,
    "debug": true,
    "restartOnError": false
  }
}'.
	self write: fileContents toFile: tempJsonFile.
	discoverer := EDAAJsonFileDiscoverer forJsonFile: tempJsonFile.
	self
		assert: discoverer isNotNil;
		assert: discoverer candidates isNotEmpty;
		assert: discoverer candidates size equals: 1;
		assert: discoverer candidates first isNotNil.
	commandListener := discoverer candidates first.
	self
		assert: commandListener isNotNil;
		assert: commandListener key equals: 'commandListener';
		assert: (commandListener value at: 'host') equals: 'localhost';
		assert: (commandListener value at: 'port') equals: 61613;
		assert: (commandListener value at: 'user') equals: 'user';
		assert: (commandListener value at: 'password') equals: 'secret';
		assert: (commandListener value at: 'queue')
			equals: 'messages-to-eda';
		assert: (commandListener value at: 'durable') equals: true;
		assert: (commandListener value at: 'ack')
			equals: 'client-individual';
		assert: (commandListener value at: 'prefetchCount') equals: 1;
		assert: (commandListener value at: 'timeout') equals: 60;
		assert: (commandListener value at: 'debug') equals: true;
		assert: (commandListener value at: 'restartOnError') equals: false
]]]

All tests are passing again.

!!! Figure out the adapter class

We'd like the new ==EDAACandidate== to help us figuring out the actual class of the adapter it represents.
The simplest behavior is to use class names as keys. Let's start with approach.

% ${changes:path=code/013-EDAACandidateTest_testAdapterClassAsCandidateKey.ombu}$
[[[methodDefinition=true|lineNumber=true
testAdapterClassAsCandidateKey
	| candidate |
	candidate := EDAACandidate withKey: 'EDAAMongoEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMongoEventStore
]]]

We have to implement the new method ""adapterClass"".

% ${changes:path=code/014-EDAACandidate_adapterClass.ombu}$
[[[methodDefinition=true|lineNumber=true
adapterClass
	^ #EDAAMongoEventStore
]]]

This has helped us to think of the method name, but the implementation is incorrect. Let's improve the test to fix it.

% ${changes:path=code/015-EDAACandidateTest_testAdapterClassAsCandidateKey.ombu}$
[[[methodDefinition=true|lineNumber=true
testAdapterClassAsCandidateKey
	| candidate |
	candidate := EDAACandidate withKey: 'EDAAMongoEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMongoEventStore.
	candidate := EDAACandidate withKey: 'EDAAMemoryEventStore' value: nil.
	self assert: candidate adapterClass equals: #EDAAMemoryEventStore
]]]

The simplest implementation of ""adapterClass"" passing the test is:

% ${changes:path=code/016-EDAACandidate_adapterClass.ombu}$
[[[methodDefinition=true|lineNumber=true
adapterClass
	^ self key asSymbol
]]]

Using adapter names as keys is a valid approach, but it's not enough for us:
- it's not the most readable format we can think of,
- it's not flexible,
- it doesn't support current PharoEDA configuration files.

Metacello new repository: 'github://osoco/pharo-eda-sample-app:main'; baseline: #PharoEDASampleApp; load

EDALogEvent (EDAEventNotProjected)
EDAEventStore
EDAEventSourcingEvent

EDATopicPublisher
EDATopicListener

DUEnvironment (EDADUEnvironment)

EDAStompTopicListener (EDAEventStompTopicListener)
EDAStompTopicPublisher (EDACommandStompTopicPublisher)

EDAAVOMongoRepository -> EDAPrintOnHelper

This package depends on the following classes:
  EDAEventStore
You must resolve these dependencies before you will be able to load these definitions:
  EDAAMemoryEventStore
  EDAAMemoryEventStore>>#allEvents
  EDAAMemoryEventStore>>#findEventsOfTenant:ofAggregate:whereCriteria:
  EDAAMemoryEventStore>>#findEventsOfTenant:ofAggregate:whereId:
  EDAAMemoryEventStore>>#initBackendRepository
  EDAAMemoryEventStore>>#saveEvents:


This package depends on the following classes:
  EDAEventStore
  EDAEventSourcingEvent
You must resolve these dependencies before you will be able to load these definitions:
  EDAAMongoEventStore
  EDAAMongoEventStore>>#authenticationMechanism
  EDAAMongoEventStore>>#authenticationMechanism:
  EDAAMongoEventStore>>#databaseName
  EDAAMongoEventStore>>#databaseName:
  EDAAMongoEventStore>>#debug
  EDAAMongoEventStore>>#debug:
  EDAAMongoEventStore>>#doInitialize
  EDAAMongoEventStore>>#enableReplication
  EDAAMongoEventStore>>#enableReplication:
  EDAAMongoEventStore>>#enableSingleton
  EDAAMongoEventStore>>#enableSingleton:
  EDAAMongoEventStore>>#ensuringCurrentOnSave
  EDAAMongoEventStore>>#ensuringCurrentOnSave:
  EDAAMongoEventStore>>#ensuringCurrentReferencesOnQueries
  EDAAMongoEventStore>>#ensuringCurrentReferencesOnQueries:
  EDAAMongoEventStore>>#forceEager
  EDAAMongoEventStore>>#forceEager:
  EDAAMongoEventStore>>#initialize
  EDAAMongoEventStore>>#lazySynchronize
  EDAAMongoEventStore>>#lazySynchronize:
  EDAAMongoEventStore>>#password
  EDAAMongoEventStore>>#password:
  EDAAMongoEventStore>>#refreshVoyageSettings
  EDAAMongoEventStore>>#refreshVoyageSettingsOn:
  EDAAMongoEventStore>>#tls
  EDAAMongoEventStore>>#tls:
  EDAAMongoEventStore>>#urls
  EDAAMongoEventStore>>#urls:
  EDAAMongoEventStore>>#username
  EDAAMongoEventStore>>#username:
  EDAAMongoEventStore>>#wireProtocolEnabled
  EDAAMongoEventStore>>#wireProtocolEnabled:
  EDAAMongoEventStore>>#allEventsOfTenant:
  EDAAMongoEventStore>>#findEventsOfTenant:ofAggregate:whereCriteria:
  EDAAMongoEventStore>>#findEventsOfTenant:ofAggregate:whereId:
  EDAAMongoEventStore>>#initBackendRepository
  EDAAMongoEventStore>>#mongoRepositoryClass
  EDAAMongoEventStore>>#saveEvents:
  EDAEventSourcingEvent>>#isVoyageRoot
  EDAEventSourcingEvent>>#voyageRepository
  EDAEventSourcingEvent>>#voyageRepository:


This package depends on the following classes:
  EDATopicPublisher
  EDATopicListener
You must resolve these dependencies before you will be able to load these definitions:
  EDAACommandStompTopicListener
  EDAAEventStompTopicPublisher
  EDAAEventStompTopicPublisher>>#publishEvent:
  EDAAEventStompTopicPublisher>>#publishEvent:inTransaction:
  EDAAEventStompTopicPublisher>>#publishEvent:withRoutingKey:
  EDAAEventStompTopicPublisher>>#publishEventsAtomically:
  EDAAStompTopicListener
  EDAAStompTopicListener>>#logDebugMessage:beautify:
  EDAAStompTopicListener>>#logErrorMessage:beautify:
  EDAAStompTopicListener>>#logFinish:usingClient:withConfig:
  EDAAStompTopicListener>>#logInfoMessage:beautify:
  EDAAStompTopicListener>>#logReceivingMessage:usingClient:from:
  EDAAStompTopicListener>>#logTraceMessage:beautify:
  EDAAStompTopicListener>>#logWarningMessage:beautify:
  EDAAStompTopicListener>>#withConfig:
  EDAAStompTopicListener>>#asyncOnMessageDo:usingClient:withConfig:
  EDAAStompTopicListener>>#buildClientWith:
  EDAAStompTopicListener>>#buildIdUsingClient:withConfig:
  EDAAStompTopicListener>>#client
  EDAAStompTopicListener>>#client:
  EDAAStompTopicListener>>#close
  EDAAStompTopicListener>>#config
  EDAAStompTopicListener>>#config:
  EDAAStompTopicListener>>#forceUnsubscribe
  EDAAStompTopicListener>>#listenerProcess
  EDAAStompTopicListener>>#listenerProcess:
  EDAAStompTopicListener>>#logFinish:usingClient:withConfig:
  EDAAStompTopicListener>>#logInit:usingClient:withConfig:
  EDAAStompTopicListener>>#nextId
  EDAAStompTopicListener>>#onMessageDo:
  EDAAStompTopicListener>>#resetClient
  EDAAStompTopicListener>>#subscribe
  EDAAStompTopicListener>>#subscribe:usingClient:withConfig:
  EDAAStompTopicListener>>#subscriptionId
  EDAAStompTopicListener>>#subscriptionId:
  EDAAStompTopicListener>>#syncOnMessageDo:usingClient:withConfig:
  EDAAStompTopicListener>>#unsubscribe
  EDAAStompTopicListener>>#unsubscribe:usingClient:
  EDAAStompTopicPublisher
  EDAAStompTopicPublisher>>#logDebugMessage:beautify:
  EDAAStompTopicPublisher>>#logErrorMessage:beautify:
  EDAAStompTopicPublisher>>#logInfoMessage:beautify:
  EDAAStompTopicPublisher>>#logTraceMessage:beautify:
  EDAAStompTopicPublisher>>#logWarningMessage:beautify:
  EDAAStompTopicPublisher>>#withConfig:
  EDAAStompTopicPublisher>>#buildClientWith:
  EDAAStompTopicPublisher>>#buildIdUsingClient:withConfig:
  EDAAStompTopicPublisher>>#client
  EDAAStompTopicPublisher>>#client:
  EDAAStompTopicPublisher>>#destination
  EDAAStompTopicPublisher>>#destinationWithRoutingKey:
  EDAAStompTopicPublisher>>#errorDestination
  EDAAStompTopicPublisher>>#initialize
  EDAAStompTopicPublisher>>#logMessagePublished:usingClient:on:
  EDAAStompTopicPublisher>>#logPublishingMessage:usingClient:on:
  EDAAStompTopicPublisher>>#nextId
  EDAAStompTopicPublisher>>#publishError:
  EDAAStompTopicPublisher>>#publishError:message:usingClient:withConfig:
  EDAAStompTopicPublisher>>#publishMessage:
  EDAAStompTopicPublisher>>#publishMessage:inTransaction:
  EDAAStompTopicPublisher>>#publishMessage:inTransaction:usingClient:withConfig:
  EDAAStompTopicPublisher>>#publishMessage:withRoutingKey:
  EDAAStompTopicPublisher>>#publishMessage:withRoutingKey:usingClient:withConfig:
  EDAAStompTopicPublisher>>#publishMessages:inTransaction:usingClient:withConfig:
  EDAAStompTopicPublisher>>#publishMessagesAtomically:

* EDAEventStore -> EDAPrintOnHelper (en 'EDA-EventStore')

!!! EDA-Application fails:
This package depends on the following classes:
  DUEnvironment
You must resolve these dependencies before you will be able to load these definitions:
  EDADUEnvironment
  EDADUEnvironment>>#at:ifAbsent:
  EDADUEnvironment>>#currentEnvironment
  EDADUEnvironment>>#currentEnvironment:
  EDADUEnvironment>>#doInitialize
  EDADUEnvironment>>#envVarDictionary
  EDADUEnvironment>>#envVarDictionaryFiles
  EDADUEnvironment>>#environment
  EDADUEnvironment>>#environments
  EDADUEnvironment>>#isSettingBrowserOpen
  EDADUEnvironment>>#reloadSettingBrowser

!!! EDA-Application-Tests fails:
This package depends on the following classes:
  GHSimpleForwarderProxyHandler
You must resolve these dependencies before you will be able to load these definitions:
  SynchronizedStompTopicListener
  SynchronizedStompTopicListener>>#wrap:
  SynchronizedStompTopicListener>>#eventsReady
  SynchronizedStompTopicListener>>#eventsReady:
  SynchronizedStompTopicListener>>#handleOnMessageDo:
  SynchronizedStompTopicListener>>#methodsMessagesToHandle

!!! EDA-Commands fails:

This package depends on the following classes:
  EDAMessageSerializer
You must resolve these dependencies before you will be able to load these definitions:
  EDAJsonCommandSerializer
  EDAJsonCommandSerializer>>#initialize
  EDAJsonCommandSerializer>>#serialize:
  EDAJsonCommandSerializer>>#writer

!!! EDA-Commands-Tests fails:

This package depends on the following classes:
  EDAJsonEventSerializer
  EDAStompTopicListener
  EDADUEnvironment
  EDAStompTopicPublisher
You must resolve these dependencies before you will be able to load these definitions:
  EDACommandStompTopicPublisher
  EDAEventStompTopicListener
  EDAJsonTestEventSerializer
  EDAJsonTestEventSerializer>>#serialize:
  EDAJsonTestEventSerializer>>#serialize:forAggregateClass:ofType:version:
  EDATestDUEnvironment
  EDATestDUEnvironment>>#envVarDictionaryFiles
  EDATestEventStompTopicListener

!!! EDA-Domain-GT-Extensions fails:

This package depends on the following classes:
  BrStencil
You must resolve these dependencies before you will be able to load these definitions:
  EDAColumnedListEventsStencil
  EDAColumnedListEventsStencil>>#on:
  EDAColumnedListEventsStencil>>#create
  EDAColumnedListEventsStencil>>#events:
  EDAColumnedListEventsStencil>>#initialize
  EDATimelineEventsStencil
  EDATimelineEventsStencil>>#on:
  EDATimelineEventsStencil>>#create
  EDATimelineEventsStencil>>#events:
  EDATimelineEventsStencil>>#initialize

!!! EDA-Errors fails:

This package depends on the following classes:
  EDAMessageSerializer
You must resolve these dependencies before you will be able to load these definitions:
  EDAJsonErrorSerializer
  EDAJsonErrorSerializer>>#withContext:andExtraContextInformation:
  EDAJsonErrorSerializer>>#context
  EDAJsonErrorSerializer>>#context:
  EDAJsonErrorSerializer>>#customJsonMappingsFor:
  EDAJsonErrorSerializer>>#extraContextInformation
  EDAJsonErrorSerializer>>#extraContextInformation:
  EDAJsonErrorSerializer>>#print:inJsonWriter:
  EDAJsonErrorSerializer>>#printException:inJsonWriter:
  EDAJsonErrorSerializer>>#serialize:
  EDAJsonErrorSerializer>>#serialize:withContext:andExtraContextInformation:

!!! EDA-Events fails:

This package depends on the following classes:
  EDAMessageSerializer
You must resolve these dependencies before you will be able to load these definitions:
  EDAJsonEventSerializer
  EDAJsonEventSerializer>>#asEventName:
  EDAJsonEventSerializer>>#buildBodySectionForEvent:
  EDAJsonEventSerializer>>#buildMetaSectionForEvent:
  EDAJsonEventSerializer>>#customJsonMappingsFor:
  EDAJsonEventSerializer>>#serialize:
  EDAJsonEventSerializer>>#writeError:
